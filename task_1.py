"""
1. Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в
виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение
Обязательно сделайте замеры времени обеих реализаций
и обосновать дала ли оптимизация эффективность

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.

Сделайте выводы!!!
Опишите в чем была ваша доработка и помогла ли вам доработка??
"""
import random
import timeit



def descent_bubble(a):
    '''Сортировка "пузырьком" по убыванию'''
    n = len(a)
    cnt = 0
    for i in range(n - 1):
        for j in range(n - i - 1):
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
            cnt += 1
    # print(a)
    return cnt


def descent_bubble_mod(a):
    '''Сортировка улучшенная'''
    n = len(a)
    cnt = 0
    for i in range(n - 1):
        flag = True
        for j in range(n - i - 1):
            if a[j] < a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
                flag = False
            cnt += 1
        if flag:
            break

    # print(a)
    return cnt

def testing(func, lst, numb):
    print('Тестируем:', func.__doc__)
    print('исходный массив', lst)
    cnt = func(lst)
    print('тест №', numb,  'проходов:', cnt)
    print('сортированный массив', lst)
    print()

for i in range(1, 4):
    lst = [random.randint(-100, 100) for _ in range(10)]
    testing(descent_bubble, lst[::], i)
    testing(descent_bubble_mod, lst[::], i)

print('---------- замеры времени _________________________')

print(
    timeit.timeit(
        "descent_bubble(lst[:])",
        globals=globals(),
        number=10000))

print(
    timeit.timeit(
        "descent_bubble_mod(lst[:])",
        globals=globals(),
        number=10000))

print(lst)  # проверка, что исходный массив не сортирован, работали с копией

'''
Тестируем: Сортировка "пузырьком" по убыванию
исходный массив [16, 75, 89, 40, 70, 13, 65, 68, -6, 13]
тест № 3 проходов: 45
сортированный массив [89, 75, 70, 68, 65, 40, 16, 13, 13, -6]

Тестируем: Сортировка улучшенная
исходный массив [16, 75, 89, 40, 70, 13, 65, 68, -6, 13]
тест № 3 проходов: 35
сортированный массив [89, 75, 70, 68, 65, 40, 16, 13, 13, -6]

---------- замеры времени _________________________
0.2967635439999867
0.16236369699981879

Видно, что алгоритм немного ускорился. Когда на одном из очередных проходов 
обмены больше не нужны, все элементы списка уже находятся на своих местах, 
то есть список отсортирован, можно остановиться.
Сокращается количество итераций цикла, а также время.
'''
